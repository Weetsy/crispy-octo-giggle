"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getElectronModulePath = getElectronModulePath;
exports.getElectronVersion = getElectronVersion;
exports.updateElectronDependency = updateElectronDependency;
exports.PackageNotFoundError = void 0;

require("source-map-support/register");

var _debug = _interopRequireDefault(require("debug"));

var _findUp = _interopRequireDefault(require("find-up"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _yarnOrNpm = _interopRequireWildcard(require("./yarn-or-npm"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:electron-version');
const electronPackageNames = ['electron-prebuilt-compile', 'electron-prebuilt', 'electron-nightly', 'electron'];

function findElectronDep(dep) {
  return electronPackageNames.includes(dep);
}

async function findAncestorNodeModulesPath(dir) {
  if ((0, _yarnOrNpm.hasYarn)()) {
    const yarnLockPath = await (0, _findUp.default)('yarn.lock', {
      cwd: dir,
      type: 'file'
    });

    if (yarnLockPath) {
      const nodeModulesPath = _path.default.join(_path.default.dirname(yarnLockPath), 'node_modules');

      if (await _fsExtra.default.pathExists(nodeModulesPath)) {
        return nodeModulesPath;
      }
    }
  }

  return Promise.resolve(undefined);
}

async function determineNodeModulesPath(dir) {
  const nodeModulesPath = _path.default.join(dir, 'node_modules');

  if (await _fsExtra.default.pathExists(nodeModulesPath)) {
    return nodeModulesPath;
  }

  return findAncestorNodeModulesPath(dir);
}

class PackageNotFoundError extends Error {
  constructor(packageName, dir) {
    super(`Cannot find the package "${packageName}". Perhaps you need to run "${(0, _yarnOrNpm.default)()} install" in "${dir}"?`);
  }

}

exports.PackageNotFoundError = PackageNotFoundError;

function getElectronModuleName(packageJSON) {
  if (!packageJSON.devDependencies) {
    throw new Error('package.json for app does not have any devDependencies');
  }

  const packageName = electronPackageNames.find(pkg => packageJSON.devDependencies[pkg]);

  if (packageName === undefined) {
    throw new Error('Could not find any Electron packages in devDependencies');
  }

  return packageName;
}

async function getElectronPackageJSONPath(dir, packageName) {
  const nodeModulesPath = await determineNodeModulesPath(dir);

  if (!nodeModulesPath) {
    throw new PackageNotFoundError(packageName, dir);
  }

  const electronPackageJSONPath = _path.default.join(nodeModulesPath, packageName, 'package.json');

  if (await _fsExtra.default.pathExists(electronPackageJSONPath)) {
    return electronPackageJSONPath;
  }

  return undefined;
}

async function getElectronModulePath(dir, packageJSON) {
  const moduleName = await getElectronModuleName(packageJSON);
  const packageJSONPath = await getElectronPackageJSONPath(dir, moduleName);

  if (packageJSONPath) {
    return _path.default.dirname(packageJSONPath);
  }

  return undefined;
}

async function getElectronVersion(dir, packageJSON) {
  const packageName = getElectronModuleName(packageJSON);
  let version = packageJSON.devDependencies[packageName];

  if (!_semver.default.valid(version)) {
    // It's not an exact version, find it in the actual module
    const electronPackageJSONPath = await getElectronPackageJSONPath(dir, packageName);

    if (electronPackageJSONPath) {
      const electronPackageJSON = await _fsExtra.default.readJson(electronPackageJSONPath); // eslint-disable-next-line prefer-destructuring

      version = electronPackageJSON.version;
    } else {
      throw new PackageNotFoundError(packageName, dir);
    }
  }

  return version;
}

function updateElectronDependency(packageJSON, dev, exact) {
  const alteredDev = [].concat(dev);
  let alteredExact = [].concat(exact);

  if (Object.keys(packageJSON.devDependencies).find(findElectronDep)) {
    alteredExact = alteredExact.filter(dep => dep !== 'electron');
  } else {
    const electronKey = Object.keys(packageJSON.dependencies).find(findElectronDep);

    if (electronKey) {
      alteredExact = alteredExact.filter(dep => dep !== 'electron');
      d(`Moving ${electronKey} from dependencies to devDependencies`);
      alteredDev.push(`${electronKey}@${packageJSON.dependencies[electronKey]}`);
      delete packageJSON.dependencies[electronKey];
    }
  }

  return [alteredDev, alteredExact];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2VsZWN0cm9uLXZlcnNpb24udHMiXSwibmFtZXMiOlsiZCIsImVsZWN0cm9uUGFja2FnZU5hbWVzIiwiZmluZEVsZWN0cm9uRGVwIiwiZGVwIiwiaW5jbHVkZXMiLCJmaW5kQW5jZXN0b3JOb2RlTW9kdWxlc1BhdGgiLCJkaXIiLCJ5YXJuTG9ja1BhdGgiLCJjd2QiLCJ0eXBlIiwibm9kZU1vZHVsZXNQYXRoIiwicGF0aCIsImpvaW4iLCJkaXJuYW1lIiwiZnMiLCJwYXRoRXhpc3RzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1bmRlZmluZWQiLCJkZXRlcm1pbmVOb2RlTW9kdWxlc1BhdGgiLCJQYWNrYWdlTm90Rm91bmRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJwYWNrYWdlTmFtZSIsImdldEVsZWN0cm9uTW9kdWxlTmFtZSIsInBhY2thZ2VKU09OIiwiZGV2RGVwZW5kZW5jaWVzIiwiZmluZCIsInBrZyIsImdldEVsZWN0cm9uUGFja2FnZUpTT05QYXRoIiwiZWxlY3Ryb25QYWNrYWdlSlNPTlBhdGgiLCJnZXRFbGVjdHJvbk1vZHVsZVBhdGgiLCJtb2R1bGVOYW1lIiwicGFja2FnZUpTT05QYXRoIiwiZ2V0RWxlY3Ryb25WZXJzaW9uIiwidmVyc2lvbiIsInNlbXZlciIsInZhbGlkIiwiZWxlY3Ryb25QYWNrYWdlSlNPTiIsInJlYWRKc29uIiwidXBkYXRlRWxlY3Ryb25EZXBlbmRlbmN5IiwiZGV2IiwiZXhhY3QiLCJhbHRlcmVkRGV2IiwiY29uY2F0IiwiYWx0ZXJlZEV4YWN0IiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsImVsZWN0cm9uS2V5IiwiZGVwZW5kZW5jaWVzIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsTUFBTUEsQ0FBQyxHQUFHLG9CQUFNLGlDQUFOLENBQVY7QUFFQSxNQUFNQyxvQkFBb0IsR0FB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TUFBYixDQUFxQjdDLEdBQUQsSUFBU0EsR0FBRyxLQUFLLFVBQXJDLENBQWY7QUFDRCxHQUZELE1BRU87QUFDTCxVQUFNOEMsV0FBVyxHQUFHSCxNQUFNLENBQUNDLElBQVAsQ0FBWXRCLFdBQVcsQ0FBQ3lCLFlBQXhCLEVBQXNDdkIsSUFBdEMsQ0FBMkN6QixlQUEzQyxDQUFwQjs7QUFDQSxRQUFJK0MsV0FBSixFQUFpQjtBQUNmSixNQUFBQSxZQUFZLEdBQUdBLFlBQVksQ0FBQ0csTUFBYixDQUFxQjdDLEdBQUQsSUFBU0EsR0FBRyxLQUFLLFVBQXJDLENBQWY7QUFDQUgsTUFBQUEsQ0FBQyxDQUFFLFVBQVNpRCxXQUFZLHVDQUF2QixDQUFEO0FBQ0FOLE1BQUFBLFVBQVUsQ0FBQ1EsSUFBWCxDQUFpQixHQUFFRixXQUFZLElBQUd4QixXQUFXLENBQUN5QixZQUFaLENBQXlCRCxXQUF6QixDQUFzQyxFQUF4RTtBQUNBLGFBQU94QixXQUFXLENBQUN5QixZQUFaLENBQXlCRCxXQUF6QixDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLENBQUNOLFVBQUQsRUFBYUUsWUFBYixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGZpbmRVcCBmcm9tICdmaW5kLXVwJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCB5YXJuT3JOcG0sIHsgaGFzWWFybiB9IGZyb20gJy4veWFybi1vci1ucG0nO1xuXG5jb25zdCBkID0gZGVidWcoJ2VsZWN0cm9uLWZvcmdlOmVsZWN0cm9uLXZlcnNpb24nKTtcblxuY29uc3QgZWxlY3Ryb25QYWNrYWdlTmFtZXMgPSBbXG4gICdlbGVjdHJvbi1wcmVidWlsdC1jb21waWxlJyxcbiAgJ2VsZWN0cm9uLXByZWJ1aWx0JyxcbiAgJ2VsZWN0cm9uLW5pZ2h0bHknLFxuICAnZWxlY3Ryb24nLFxuXTtcblxuZnVuY3Rpb24gZmluZEVsZWN0cm9uRGVwKGRlcDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBlbGVjdHJvblBhY2thZ2VOYW1lcy5pbmNsdWRlcyhkZXApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kQW5jZXN0b3JOb2RlTW9kdWxlc1BhdGgoZGlyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBpZiAoaGFzWWFybigpKSB7XG4gICAgY29uc3QgeWFybkxvY2tQYXRoID0gYXdhaXQgZmluZFVwKCd5YXJuLmxvY2snLCB7IGN3ZDogZGlyLCB0eXBlOiAnZmlsZScgfSk7XG4gICAgaWYgKHlhcm5Mb2NrUGF0aCkge1xuICAgICAgY29uc3Qgbm9kZU1vZHVsZXNQYXRoID0gcGF0aC5qb2luKHBhdGguZGlybmFtZSh5YXJuTG9ja1BhdGgpLCAnbm9kZV9tb2R1bGVzJyk7XG4gICAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhub2RlTW9kdWxlc1BhdGgpKSB7XG4gICAgICAgIHJldHVybiBub2RlTW9kdWxlc1BhdGg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkZXRlcm1pbmVOb2RlTW9kdWxlc1BhdGgoZGlyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBub2RlTW9kdWxlc1BhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHBhdGguam9pbihkaXIsICdub2RlX21vZHVsZXMnKTtcbiAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMobm9kZU1vZHVsZXNQYXRoKSkge1xuICAgIHJldHVybiBub2RlTW9kdWxlc1BhdGg7XG4gIH1cbiAgcmV0dXJuIGZpbmRBbmNlc3Rvck5vZGVNb2R1bGVzUGF0aChkaXIpO1xufVxuXG5leHBvcnQgY2xhc3MgUGFja2FnZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhY2thZ2VOYW1lOiBzdHJpbmcsIGRpcjogc3RyaW5nKSB7XG4gICAgc3VwZXIoYENhbm5vdCBmaW5kIHRoZSBwYWNrYWdlIFwiJHtwYWNrYWdlTmFtZX1cIi4gUGVyaGFwcyB5b3UgbmVlZCB0byBydW4gXCIke3lhcm5Pck5wbSgpfSBpbnN0YWxsXCIgaW4gXCIke2Rpcn1cIj9gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVjdHJvbk1vZHVsZU5hbWUocGFja2FnZUpTT046IGFueSk6IHN0cmluZyB7XG4gIGlmICghcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYWNrYWdlLmpzb24gZm9yIGFwcCBkb2VzIG5vdCBoYXZlIGFueSBkZXZEZXBlbmRlbmNpZXMnKTtcbiAgfVxuXG4gIGNvbnN0IHBhY2thZ2VOYW1lID0gZWxlY3Ryb25QYWNrYWdlTmFtZXMuZmluZCgocGtnKSA9PiBwYWNrYWdlSlNPTi5kZXZEZXBlbmRlbmNpZXNbcGtnXSk7XG4gIGlmIChwYWNrYWdlTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhbnkgRWxlY3Ryb24gcGFja2FnZXMgaW4gZGV2RGVwZW5kZW5jaWVzJyk7XG4gIH1cblxuICByZXR1cm4gcGFja2FnZU5hbWU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEVsZWN0cm9uUGFja2FnZUpTT05QYXRoKFxuICBkaXI6IHN0cmluZyxcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcbik6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IG5vZGVNb2R1bGVzUGF0aCA9IGF3YWl0IGRldGVybWluZU5vZGVNb2R1bGVzUGF0aChkaXIpO1xuICBpZiAoIW5vZGVNb2R1bGVzUGF0aCkge1xuICAgIHRocm93IG5ldyBQYWNrYWdlTm90Rm91bmRFcnJvcihwYWNrYWdlTmFtZSwgZGlyKTtcbiAgfVxuICBjb25zdCBlbGVjdHJvblBhY2thZ2VKU09OUGF0aCA9IHBhdGguam9pbihub2RlTW9kdWxlc1BhdGgsIHBhY2thZ2VOYW1lLCAncGFja2FnZS5qc29uJyk7XG4gIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGVsZWN0cm9uUGFja2FnZUpTT05QYXRoKSkge1xuICAgIHJldHVybiBlbGVjdHJvblBhY2thZ2VKU09OUGF0aDtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbGVjdHJvbk1vZHVsZVBhdGgoXG4gIGRpcjogc3RyaW5nLFxuICBwYWNrYWdlSlNPTjogYW55LFxuKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgY29uc3QgbW9kdWxlTmFtZSA9IGF3YWl0IGdldEVsZWN0cm9uTW9kdWxlTmFtZShwYWNrYWdlSlNPTik7XG4gIGNvbnN0IHBhY2thZ2VKU09OUGF0aCA9IGF3YWl0IGdldEVsZWN0cm9uUGFja2FnZUpTT05QYXRoKGRpciwgbW9kdWxlTmFtZSk7XG4gIGlmIChwYWNrYWdlSlNPTlBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5kaXJuYW1lKHBhY2thZ2VKU09OUGF0aCk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RWxlY3Ryb25WZXJzaW9uKGRpcjogc3RyaW5nLCBwYWNrYWdlSlNPTjogYW55KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgcGFja2FnZU5hbWUgPSBnZXRFbGVjdHJvbk1vZHVsZU5hbWUocGFja2FnZUpTT04pO1xuXG4gIGxldCB2ZXJzaW9uID0gcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzW3BhY2thZ2VOYW1lXTtcbiAgaWYgKCFzZW12ZXIudmFsaWQodmVyc2lvbikpIHsgLy8gSXQncyBub3QgYW4gZXhhY3QgdmVyc2lvbiwgZmluZCBpdCBpbiB0aGUgYWN0dWFsIG1vZHVsZVxuICAgIGNvbnN0IGVsZWN0cm9uUGFja2FnZUpTT05QYXRoID0gYXdhaXQgZ2V0RWxlY3Ryb25QYWNrYWdlSlNPTlBhdGgoZGlyLCBwYWNrYWdlTmFtZSk7XG4gICAgaWYgKGVsZWN0cm9uUGFja2FnZUpTT05QYXRoKSB7XG4gICAgICBjb25zdCBlbGVjdHJvblBhY2thZ2VKU09OID0gYXdhaXQgZnMucmVhZEpzb24oZWxlY3Ryb25QYWNrYWdlSlNPTlBhdGgpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICB2ZXJzaW9uID0gZWxlY3Ryb25QYWNrYWdlSlNPTi52ZXJzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFja2FnZU5vdEZvdW5kRXJyb3IocGFja2FnZU5hbWUsIGRpcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZlcnNpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVFbGVjdHJvbkRlcGVuZGVuY3koXG4gIHBhY2thZ2VKU09OOiBhbnksXG4gIGRldjogc3RyaW5nW10sXG4gIGV4YWN0OiBzdHJpbmdbXSxcbik6IFtzdHJpbmdbXSwgc3RyaW5nW11dIHtcbiAgY29uc3QgYWx0ZXJlZERldiA9IChbXSBhcyBzdHJpbmdbXSkuY29uY2F0KGRldik7XG4gIGxldCBhbHRlcmVkRXhhY3QgPSAoW10gYXMgc3RyaW5nW10pLmNvbmNhdChleGFjdCk7XG4gIGlmIChPYmplY3Qua2V5cyhwYWNrYWdlSlNPTi5kZXZEZXBlbmRlbmNpZXMpLmZpbmQoZmluZEVsZWN0cm9uRGVwKSkge1xuICAgIGFsdGVyZWRFeGFjdCA9IGFsdGVyZWRFeGFjdC5maWx0ZXIoKGRlcCkgPT4gZGVwICE9PSAnZWxlY3Ryb24nKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBlbGVjdHJvbktleSA9IE9iamVjdC5rZXlzKHBhY2thZ2VKU09OLmRlcGVuZGVuY2llcykuZmluZChmaW5kRWxlY3Ryb25EZXApO1xuICAgIGlmIChlbGVjdHJvbktleSkge1xuICAgICAgYWx0ZXJlZEV4YWN0ID0gYWx0ZXJlZEV4YWN0LmZpbHRlcigoZGVwKSA9PiBkZXAgIT09ICdlbGVjdHJvbicpO1xuICAgICAgZChgTW92aW5nICR7ZWxlY3Ryb25LZXl9IGZyb20gZGVwZW5kZW5jaWVzIHRvIGRldkRlcGVuZGVuY2llc2ApO1xuICAgICAgYWx0ZXJlZERldi5wdXNoKGAke2VsZWN0cm9uS2V5fUAke3BhY2thZ2VKU09OLmRlcGVuZGVuY2llc1tlbGVjdHJvbktleV19YCk7XG4gICAgICBkZWxldGUgcGFja2FnZUpTT04uZGVwZW5kZW5jaWVzW2VsZWN0cm9uS2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2FsdGVyZWREZXYsIGFsdGVyZWRFeGFjdF07XG59XG4iXX0=